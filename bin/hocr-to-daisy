#!/usr/bin/env python

import argparse
import os
import re
import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, OrderedDict

from internetarchiveocr.language import language_to_alpha3lang
import iso639

import hocr
from derivermodule.scandata import scandata_parse
from hocr import daisy


class DaisyGenerator:
    __version__ = '1.0.0'

    toc = None
    metadata = None

    def __init__(
        self,
        hocr_xml_file_path: str,
        ia_item_name: str = "",
        ia_item_path: str = "",
        ia_doc_name: str = "",
    ) -> None:
        self.hocr_xml_file_path = hocr_xml_file_path
        self.ia_item_name = ia_item_name
        self.ia_item_path = ia_item_path
        self.ia_doc_name = ia_doc_name
        self.scandata = scandata_parse(self.get_scandata_path())

    def get_hocr(self):
        if os.path.exists(self.hocr_xml_file_path):
            return open(self.hocr_xml_file_path, 'rb')
        raise FileNotFoundError('No hOCR file found')

    def get_scandata_path(self) -> str:
        paths = [
            os.path.join(self.ia_item_path, self.ia_doc_name + '_scandata.xml'),
            os.path.join(self.ia_item_path, 'scandata.xml'),
            os.path.join(self.ia_item_path, 'scandata.zip'),
        ]
        for sd_path in paths:
            if os.path.exists(sd_path):
                return sd_path
        raise FileNotFoundError('No scandata found')

    # TODO: candidate for removal/refactor
    def get_bookdata(self) -> OrderedDict:
        """Get the `book` metadata from scandata."""
        book_data = self.scandata.get("book")
        if not book_data:
            raise ValueError("Expected book data")

        return book_data

    # TODO: candidate for removal/refactor
    def get_metadata(self) -> List[Dict[str, str]]:
        if self.metadata:
            return self.metadata
        md_path = os.path.join(self.ia_item_path, self.ia_item_name + '_meta.xml')
        md = ET.parse(md_path).getroot()
        result = []
        for el in md:
            if el.tag == 'language' and el.text:
                lang = language_to_alpha3lang(el.text)
                if lang is not None:
                    result_text = iso639.languages.get(part3=lang).alpha2
                else:
                    result_text = el.text
            else:
                result_text = el.text
            result.append({'tag': el.tag, 'text': result_text})
        self.metadata = result
        return result

    def get_toc(self):
        if self.toc is not None:
            return self.toc
        toc_path = os.path.join(self.ia_item_path, self.ia_doc_name + '_toc.xml')
        if not os.path.exists(toc_path):
            return None
        toc = ET.parse(toc_path).getroot()
        result = {el.get('page'): el.get('title') for el in toc}
        return result

    def has_pagenos(self) -> bool:
        """Determine whether the book has page numbers."""
        pages = self.get_scandata_pages()
        for page in pages:
            has_pagenumber = page.get("pageNumber")
            if has_pagenumber is not None:
                return True

        return False

    def get_page_scandata(self, page_number: int) -> Optional[OrderedDict]:
        """Get the scandata for an individual page."""
        pages = self.get_scandata_pages()
        if page_number > len(pages):
            return None
        return pages[int(page_number)]

    def get_scandata_pages(self) -> List[OrderedDict]:
        """Return the scandata pages data."""
        book = self.get_bookdata()
        return book['pageData']['page']

    # TODO: candidate for removal/refactor
    def par_is_pageno_header_footer_hocr(self, par) -> bool:
        if len(par['lines']) != 1:
            return False

        line = par['lines'][0]

        line_text = hocr.text.hocr_paragraph_text({'lines': [line]})
        if re.match(
            r'[\[li] *[0-9afhiklmnouvx^]*[0-9][0-9afhiklmnouvx^]* *[\]ijl1]', line_text
        ):
            return True
        if re.match(r'[\[li] *[xiv]* *[\]ijl1]', line_text):
            return True

        for word in line['words']:
            if word['fontsize'] > 40:
                continue
            if daisy.util.roman_to_num(word['text'].lower()) > 0:
                return True
            # common OCR errors
            if re.match('[0-9io]+', word['text']):
                return True
            if re.match('[0-9afhiklmnouvx^]*[0-9][0-9afhiklmnouvx^]*', word['text']):
                return True

        return False

    # TODO: candidate for removal/refactor
    def our_hocr_paragraph_text(self, paragraph):
        word_confidences = []
        par_text = ''

        for line in paragraph['lines']:
            if par_text[-2:] == '- ':
                par_text = par_text[:-2]

            line_words = ''
            for word in line['words']:
                if word['text'].endswith(' '):
                    line_words += word['text']
                else:
                    line_words += word['text'] + ' '

            # Encode
            line_words = line_words.encode('utf-8')
            # line_words = line_words.strip().encode('utf-8')

            # Write out
            if line_words:
                par_text += line_words.decode('utf-8')

        if par_text:
            # Strip last space
            par_text = par_text[:-1]

        return par_text

    def process_book_hocr(self, ebook: "daisy.book.DaisyBook", alt_booktext=None):
        hocr_file = self.get_hocr()
        contents = self.get_toc()
        metadata = self.get_metadata()

        title = daisy.book.get_metadata_tag_data(metadata, 'title')
        if title is None:
            title = ''

        author = daisy.book.get_metadata_tag_data(metadata, 'creator')
        if author is None:
            author = ''

        ebook.push_tag('frontmatter')
        ebook.add_tag('doctitle', title)
        ebook.add_tag('docauthor', author)

        ebook.push_navpoint('level', 'h', 'Producer\'s Note')
        ebook.push_navpoint('level', 'h', 'About Internet Archive Daisy Books')
        ebook.add_tag(
            'p',
            """This book was produced in DAISY format by the Internet Archive.  The
        book pages were scanned and converted to DAISY format
        automatically.  This process relies on optical character
        recognition, and is somewhat susceptible to errors.  These errors
        may include weird characters, non-words, and incorrect guesses at
        structure.  Page numbers and headers or footers may remain from
        the scanned page.  The Internet Archive is working to improve the
        scanning process and resulting books, but in the meantime, we hope
        that this book will be useful to you.
        """,
        )
        ebook.pop_navpoint()
        ebook.push_navpoint('level', 'h', 'About this DAISY book')
        has_nav = False
        if self.has_pagenos():
            has_nav = True
            ebook.add_tag('p', "This book has page navigation.")
        if contents is not None:
            has_nav = True
            ebook.add_tag('p', "This book has chapter navigation.")
        if not has_nav:
            ebook.add_tag(
                'p', "This book as paragraph navigation, but is otherwise unstructured."
            )
        ebook.pop_navpoint()
        ebook.push_navpoint('level', 'h', 'About the Internet Archive')
        ebook.add_tag(
            'p',
            """The Internet Archive was founded in 1996
        to build an Internet library
    and to promote universal access to all knowledge.  The Archive's purposes
    include offering permanent access for researchers, historians,
    scholars, people with disabilities, and the general public to
    historical collections that exist in digital format.  The Internet Archive
    includes texts, audio, moving images, and software as well as archived
    web pages, and provides specialized services for information access
    for the blind and other persons with disabilities.
        """,
        )
        ebook.pop_navpoint()
        ebook.pop_navpoint()

        ebook.pop_tag()
        ebook.push_tag('bodymatter')

        if contents is None:
            ebook.push_navpoint('level', 'h', 'Book')

        part_number = 0
        cover_number = 0
        pushed_navpoint = False

        hocr_iterator = hocr.parse.hocr_page_iterator(hocr_file)

        before_title_page = True
        for i, page in enumerate(hocr_iterator):
            # wrap in try/finally to ensure page.clear() is called
            try:
                if alt_booktext is not None:
                    ebook.add_tag('p', alt_booktext)
                    break

                page_scandata = self.get_page_scandata(i)
                pageno = None
                if page_scandata is not None:
                    pageno = page_scandata.get('pageNumber')
                if pageno is not None:
                    if contents is not None and pageno in contents:
                        if pushed_navpoint:
                            ebook.pop_navpoint()
                        ebook.push_navpoint('level', 'h', contents[pageno])
                        pushed_navpoint = True
                    ebook.add_pagetarget(pageno, pageno)

                if not page_scandata:
                    continue

                if page_scandata.get('pageType', '').lower() in ('title', 'title page'):
                    before_title_page = False

                if page_scandata.get('addToAccessFormats') == 'false':
                    continue

                if before_title_page:
                    continue

                first_par = True
                saw_pageno_header_footer = False

                pars = list(hocr.parse.hocr_page_to_word_data(page))

                for paridx, par in enumerate(pars):
                    # First paragraph
                    if first_par and self.par_is_pageno_header_footer_hocr(par):
                        saw_pageno_header_footer = True
                        first_par = False
                        continue
                    first_par = False

                    # Last paragraph
                    if (
                        not saw_pageno_header_footer
                        and paridx == len(pars) - 1
                        and self.par_is_pageno_header_footer_hocr(par)
                    ):
                        saw_pageno_header_footer = True
                        continue

                    par_text = self.our_hocr_paragraph_text(par)
                    ebook.add_tag('p', par_text)
            finally:
                pass

        if pushed_navpoint:
            ebook.pop_navpoint()

        if contents is None:
            ebook.pop_navpoint()  # level1

        ebook.pop_tag()
        ebook.push_tag('rearmatter')
        ebook.push_tag('level1')
        ebook.add_tag('p', 'End of book')
        ebook.pop_tag()
        ebook.pop_tag()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='hOCR to DAISY converter')

    parser.add_argument(
        '-f', '--infile', help='Item _hocr.html file', type=str, default=None
    )
    parser.add_argument(
        '-o', '--outfile', help='Output DAISY zip', type=str, default=None
    )
    parser.add_argument(
        '-w',
        '--workingdir',
        help='Directory used for temp files',
        type=str,
        default=None,
    )
    parser.add_argument(
        '-i',
        '--itemdir',
        help='Directory of the Internet Archive item',
        type=str,
        default=None,
    )
    parser.add_argument(
        '-n', '--itemname', help='Internet Archive item name', type=str, default=None
    )
    parser.add_argument(
        '-d', '--docname', help='Internet Archive document name', type=str, default=None
    )

    args = parser.parse_args()

    if not args.infile:
        raise Exception('Must provide hOCR input file with -f')

    # Allow external caller to override working directory from default /tmp/ or /var/tmp/fast/
    if args.workingdir:
        WORKING_DIR = args.workingdir

    # The relation of these will need to be rethought.
    # TODO: should be args.infile
    dg = DaisyGenerator(
        hocr_xml_file_path=args.infile,
        ia_item_name=args.itemname,
        ia_item_path=args.itemdir,
        ia_doc_name=args.docname,
    )
    metadata = dg.get_metadata()

    daisy_book = daisy.book.DaisyBook(out_name=args.outfile, metadata=metadata)
    dg.process_book_hocr(ebook=daisy_book)
    daisy_book.finish(metadata)
